<!DOCTYPE html>
<html lang="en">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="UTF-8">
  <title>Queztaz/Automating Chkdsk Scans Using Powershell With Email Alerts for Rmm</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="/css/gtd.css">
  
  
</head>
<body>
  
<main>
  <div style="margin: 1rem;">
    <a href="/" style="
      display: inline-block;
      background-color: #eee;
      color: #333;
      padding: 0.4rem 0.8rem;
      border-radius: 6px;
      text-decoration: none;
      font-weight: bold;
      font-family: sans-serif;
      font-size: 0.9rem;
    ">
      ‚Üê Homepage
    </a>

  <h1>Automating Chkdsk Scans Using Powershell With Email Alerts for Rmm</h1>

  </div>
  <nav class="toc">
    <nav id="TableOfContents">
<ul>
<li><a href="#headline-1">What this does</a>
</li>
<li><a href="#headline-2">How to implement with RMM</a>
</li>
<li><a href="#headline-3">Running standalone</a>
</li>
<li><a href="#headline-4">Source Code</a>
</li>
</ul>
</nav>
  </nav> 

  <article>
    
<div id="outline-container-headline-1" class="outline-2">
<h2 id="headline-1">
What this does
</h2>
<div id="outline-text-headline-1" class="outline-text-2">
<p>Automatically schedules windows filesystem checks if the drive is detected to
have corruption. If corruption occurs more than once per week, an email is sent
out to your desired address. SFC &amp; DISM scans are scheduled for 10PM. CHKDSKs on
the corrupt drive are scheduled for 12AM</p>
<p>
This can be run standalone, although ideally you set it up as an automatic
response in your RMM software. There are failsafes in place to prevent the
script from running multiple times due to alert spam.</p>
<p>
<strong><strong>Important</strong></strong>: A python EXE file is used to send the emails out. The source code
to script is on my github <a href="https://github.com/peterunix/Python-Sendmail">LINK</a>. The build in this project is compiled from that.</p>
</div>
</div>
<div id="outline-container-headline-2" class="outline-2">
<h2 id="headline-2">
How to implement with RMM
</h2>
<div id="outline-text-headline-2" class="outline-text-2">
<ul>
<li>Edit the script and add your SMTP credentials on the last line.</li>
<li>Add this script as a component in your RMM</li>
<li>Update your RMM and have the script be a response to the following event
errors</li>
</ul>
<div class="src src-text">
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Get-EventLog -LogName System -EntryType Error -Source Ntfs -Message &#34;A corruption was discovered in the file system structure on volume*&#34; -ErrorAction &#39;SilentlyContinue&#39;
</span></span><span style="display:flex;"><span>Get-EventLog -LogName System -EntryType Error -Source Disk -Message &#34;The device, *has a bad block*&#34; -ErrorAction &#39;SilentlyContinue&#39;
</span></span><span style="display:flex;"><span>Get-EventLog -LogName System -EntryType Error -Source Disk -Message &#34;The driver detected a controller error on*&#34; -ErrorAction &#39;SilentlyContinue&#39;</span></span></code></pre></div>
</div>
</div>
</div>
<div id="outline-container-headline-3" class="outline-2">
<h2 id="headline-3">
Running standalone
</h2>
<div id="outline-text-headline-3" class="outline-text-2">
<p>You can schedule this to run automatically on your PC through the task
scheduler. My suggestion is have it run daily at some arbitrary hour.</p>
</div>
</div>
<div id="outline-container-headline-4" class="outline-2">
<h2 id="headline-4">
Source Code
</h2>
<div id="outline-text-headline-4" class="outline-text-2">
<p>My Github: <a href="https://github.com/peterunix/PS-ScheduleCHKDSKandScans"><a href="https://github.com/peterunix/PS-ScheduleCHKDSKandScans">https://github.com/peterunix/PS-ScheduleCHKDSKandScans</a></a></p>
<div class="src src-powershell">
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span><span style="color:#75715e">&lt;#
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">.</span><span style="color:#e6db74">SYNOPSIS</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">Scans the event log for drive errors. Schedules SFC &amp; DISM Scan to run
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">at 10PM and CHKDSKs at 12AM.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">.</span><span style="color:#e6db74">DESCRIPTION</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">Event logs are created with timestamps of when the script ran
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">successfully and scheduled a CHKDSK.  Additionally, the file
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">C:\Windows\LastChkdsk.txt is created with the same event log
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">data. This file&#39;s timestamp is checked to make sure the chkdsk doesn&#39;t
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">run more than once a week. If the last CHKDSK was within the week, an
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">email will be sent out VIA SMTP to your address. In theory, a drive
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">with frequently corrupt blocks is failing hence the email alert.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">The way bad drives are identified is through searching the event log
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">and then locating the drive using the event logs message data. Hard
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">coded is the pattern matching and proper commands to find the drive
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">associated with a bad block error.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">If you wish to extend this script to include more event log
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">detections, the _LocateEvents and _Schedulechkdsk functions are what
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">you&#39;re interested in
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">.</span><span style="color:#e6db74">NOTES</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">Best practice is to configure this as an automatic response to your
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">device monitoring alerts in RMM. There&#39;s are failsafe methods to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">ensure that this script doesn&#39;t run multiple times for the same alert.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">.</span><span style="color:#e6db74">LINK</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">Github: https://github.com/peterunix/PS-ScheduleCHKDSKandScans
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> _CreateEventLogEntry{
</span></span><span style="display:flex;"><span><span style="color:#75715e">&lt;#
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">Create a custom event log. Used later on when reporting the time and
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">reason a CHKDSK scan was done
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">param</span> (
</span></span><span style="display:flex;"><span>	[Parameter(<span style="color:#a6e22e">Mandatory</span>=$true)][<span style="color:#66d9ef">string</span>]$Message,
</span></span><span style="display:flex;"><span>	[Parameter(<span style="color:#a6e22e">Mandatory</span>=$true)][<span style="color:#66d9ef">string</span>]$LogName,
</span></span><span style="display:flex;"><span>	[Parameter(<span style="color:#a6e22e">Mandatory</span>=$true)][<span style="color:#66d9ef">string</span>]$LogType,
</span></span><span style="display:flex;"><span>	[Parameter(<span style="color:#a6e22e">Mandatory</span>=$true)][<span style="color:#66d9ef">string</span>]$LogSource
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Define the log name and source</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Check if the source exists; if not, create it</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">-not</span> [<span style="color:#66d9ef">System.Diagnostics.EventLog</span>]::SourceExists($LogSource)){
</span></span><span style="display:flex;"><span>	New-EventLog -LogName $LogName -Source $LogSource
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Define the event message and event ID</span>
</span></span><span style="display:flex;"><span>    $eventID = <span style="color:#ae81ff">1000</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Convert the string LogType to EventLogEntryType</span>
</span></span><span style="display:flex;"><span>    $entryType = [<span style="color:#66d9ef">System.Diagnostics.EventLogEntryType</span>]::Information
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">switch</span> ($LogType) {
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;Error&#34;</span> { $entryType = [<span style="color:#66d9ef">System.Diagnostics.EventLogEntryType</span>]::Error }
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;Warning&#34;</span> { $entryType = [<span style="color:#66d9ef">System.Diagnostics.EventLogEntryType</span>]::Warning }
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;Information&#34;</span> { $entryType = [<span style="color:#66d9ef">System.Diagnostics.EventLogEntryType</span>]::Information }
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;SuccessAudit&#34;</span> { $entryType = [<span style="color:#66d9ef">System.Diagnostics.EventLogEntryType</span>]::SuccessAudit }
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;FailureAudit&#34;</span> { $entryType = [<span style="color:#66d9ef">System.Diagnostics.EventLogEntryType</span>]::FailureAudit }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">default</span> { <span style="color:#66d9ef">throw</span> <span style="color:#e6db74">&#34;Invalid LogType: </span>$LogType<span style="color:#e6db74">&#34;</span> }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Write the informational event to the log</span>
</span></span><span style="display:flex;"><span>    Write-EventLog -LogName $LogName -Source $LogSource -EventId $eventID -EntryType $entryType -Message $message
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Lists the hard disk name (\\device\harddisvolume4) and the drive letter its mounted to (C:)</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> _GetHarddiskVolumes{
</span></span><span style="display:flex;"><span><span style="color:#75715e">&lt;#
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">Returns a list of hard disk names (\\device\harddiskvolume4) and the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">drive letter its mounted to. It&#39;s used to find the drive letter by
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">searching the hard disk name given in the event log
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Build System Assembly in order to call Kernel32:QueryDosDevice.</span>
</span></span><span style="display:flex;"><span>    $DynAssembly = New-Object System.Reflection.AssemblyName(<span style="color:#e6db74">&#39;SysUtils&#39;</span>)
</span></span><span style="display:flex;"><span>    $AssemblyBuilder = [<span style="color:#66d9ef">AppDomain</span>]::CurrentDomain.DefineDynamicAssembly($DynAssembly, [<span style="color:#66d9ef">Reflection.Emit.AssemblyBuilderAccess</span>]::Run)
</span></span><span style="display:flex;"><span>    $ModuleBuilder = $AssemblyBuilder.DefineDynamicModule(<span style="color:#e6db74">&#39;SysUtils&#39;</span>, $False)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Define [Kernel32]::QueryDosDevice method</span>
</span></span><span style="display:flex;"><span>    $TypeBuilder = $ModuleBuilder.DefineType(<span style="color:#e6db74">&#39;Kernel32&#39;</span>, <span style="color:#e6db74">&#39;Public, Class&#39;</span>)
</span></span><span style="display:flex;"><span>    $PInvokeMethod = $TypeBuilder.DefinePInvokeMethod(<span style="color:#e6db74">&#39;QueryDosDevice&#39;</span>, <span style="color:#e6db74">&#39;kernel32.dll&#39;</span>, ([<span style="color:#66d9ef">Reflection.MethodAttributes</span>]::Public <span style="color:#f92672">-bor</span> [<span style="color:#66d9ef">Reflection.MethodAttributes</span>]::Static), [<span style="color:#66d9ef">Reflection.CallingConventions</span>]::Standard, [<span style="color:#66d9ef">UInt32], [Type[]</span>]@([<span style="color:#66d9ef">String], [Text.StringBuilder], [UInt32</span>]), [<span style="color:#66d9ef">Runtime.InteropServices.CallingConvention</span>]::Winapi, [<span style="color:#66d9ef">Runtime.InteropServices.CharSet</span>]::Auto)
</span></span><span style="display:flex;"><span>    $DllImportConstructor = [<span style="color:#66d9ef">Runtime.InteropServices.DllImportAttribute</span>].GetConstructor(@([<span style="color:#66d9ef">String</span>]))
</span></span><span style="display:flex;"><span>    $SetLastError = [<span style="color:#66d9ef">Runtime.InteropServices.DllImportAttribute</span>].GetField(<span style="color:#e6db74">&#39;SetLastError&#39;</span>)
</span></span><span style="display:flex;"><span>    $SetLastErrorCustomAttribute = New-Object Reflection.Emit.CustomAttributeBuilder($DllImportConstructor, @(<span style="color:#e6db74">&#39;kernel32.dll&#39;</span>), [<span style="color:#66d9ef">Reflection.FieldInfo[]</span>]@($SetLastError), @($true))
</span></span><span style="display:flex;"><span>    $PInvokeMethod.SetCustomAttribute($SetLastErrorCustomAttribute)
</span></span><span style="display:flex;"><span>    $Kernel32 = $TypeBuilder.CreateType()
</span></span><span style="display:flex;"><span>    $Max = <span style="color:#ae81ff">65536</span>
</span></span><span style="display:flex;"><span>    $StringBuilder = New-Object System.Text.StringBuilder($Max)
</span></span><span style="display:flex;"><span>    Get-WmiObject Win32_Volume | ? { $_.DriveLetter } | % {
</span></span><span style="display:flex;"><span>	$ReturnLength = $Kernel32::QueryDosDevice($_.DriveLetter, $StringBuilder, $Max)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> ($ReturnLength){
</span></span><span style="display:flex;"><span>	    $DriveMapping = @{
</span></span><span style="display:flex;"><span>		DriveLetter = $_.DriveLetter
</span></span><span style="display:flex;"><span>		DevicePath = $StringBuilder.ToString()
</span></span><span style="display:flex;"><span>	    }
</span></span><span style="display:flex;"><span>	    New-Object PSObject -Property $DriveMapping
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> _LocateEvents{
</span></span><span style="display:flex;"><span><span style="color:#75715e">&lt;#
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">Finds event related to disk errors. Returns a string with the type of
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">disk error it is. This is used in the CHKDSK function and different
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">code is ran to find the drive based off the event log.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">It only returns the most recent event. If there are two different
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">drives alerting at the same time, only one of the drives will be
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">scanned.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ($EVENT = Get-EventLog -LogName System -EntryType Error -Source Ntfs -Message <span style="color:#e6db74">&#34;A corruption was discovered in the file system structure on volume*&#34;</span> -ErrorAction <span style="color:#e6db74">&#39;SilentlyContinue&#39;</span> | Select -First <span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> ($EVENT.TimeGenerated <span style="color:#f92672">-gt</span> (Get-Date).AddDays(<span style="color:#ae81ff">-1</span>)){
</span></span><span style="display:flex;"><span>	    $EVENTTYPE = <span style="color:#e6db74">&#34;NTFS&#34;</span>
</span></span><span style="display:flex;"><span>	    <span style="color:#66d9ef">return</span> @($EVENT, $EVENTTYPE)
</span></span><span style="display:flex;"><span>	}}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ($EVENT = Get-EventLog -LogName System -EntryType Error -Source Disk -Message <span style="color:#e6db74">&#34;The device, *has a bad block*&#34;</span> -ErrorAction <span style="color:#e6db74">&#39;SilentlyContinue&#39;</span> | Select -First <span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> ($EVENT.TimeGenerated <span style="color:#f92672">-gt</span> (Get-Date).AddDays(<span style="color:#ae81ff">-1</span>)){
</span></span><span style="display:flex;"><span>	    $EVENTTYPE = <span style="color:#e6db74">&#34;Bad Block&#34;</span>
</span></span><span style="display:flex;"><span>	    <span style="color:#66d9ef">return</span> @($EVENT, $EVENTTYPE)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ($EVENT = Get-EventLog -LogName System -EntryType Error -Source Disk -Message <span style="color:#e6db74">&#34;The driver detected a controller error on*&#34;</span> -ErrorAction <span style="color:#e6db74">&#39;SilentlyContinue&#39;</span> | Select -First <span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> ($EVENT.TimeGenerated <span style="color:#f92672">-gt</span> (Get-Date).AddDays(<span style="color:#ae81ff">-1</span>)){
</span></span><span style="display:flex;"><span>	    $EVENTTYPE = <span style="color:#e6db74">&#34;Driver Detection&#34;</span>
</span></span><span style="display:flex;"><span>	    <span style="color:#66d9ef">return</span> @($EVENT, $EVENTTYPE)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ($EVENT <span style="color:#f92672">-eq</span> $null){
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;No disk error events found. Exiting gracefully&#34;</span>
</span></span><span style="display:flex;"><span>	Exit <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> _ScheduleDismSFC{
</span></span><span style="display:flex;"><span><span style="color:#75715e">&lt;#
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">Schedules an SFC and DISM to run at 10PM.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#&gt;</span>
</span></span><span style="display:flex;"><span>    $taskName = <span style="color:#e6db74">&#34;Schedule SFC &amp; DISM at 10PM&#34;</span>
</span></span><span style="display:flex;"><span>    $taskExists = Get-ScheduledTask | Where-Object {$_.TaskName <span style="color:#f92672">-match</span> $taskname }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ($taskExists){
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;The task for </span>$taskName<span style="color:#e6db74"> already exists&#34;</span>
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>	$action = New-ScheduledTaskAction -Execute <span style="color:#e6db74">&#39;C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -command &#34;sfc /scannow ; dism /online /cleanup-image /restorehealth&#34;&#39;</span>
</span></span><span style="display:flex;"><span>	$trigger = New-ScheduledTaskTrigger -Once -At 10pm
</span></span><span style="display:flex;"><span>	$task = Register-ScheduledTask -TaskName $taskName -Trigger $trigger -Action $action -User System
</span></span><span style="display:flex;"><span>	$task | Set-ScheduledTask
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> _ScheduleCHKDSK{
</span></span><span style="display:flex;"><span><span style="color:#75715e">&lt;#
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">Schedules an SFC scan and then uses the returned values of the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">_LocateEvents function to find the drive that needs to be repaired.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">Different code is required to find the drive from the event, hence the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">switch statement.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Depending on the type of error, different code will run to find the drive</span>
</span></span><span style="display:flex;"><span>    $EVENT,$EVENTTYPE = _LocateEvents
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ($EVENT <span style="color:#f92672">-eq</span> $null){
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;Didn&#39;t locate an event for a drive error thats occurred within the last 24 hours. Exiting gracefully&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;No changes were made.&#34;</span>
</span></span><span style="display:flex;"><span>	Exit <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    _ScheduleDismSFC
</span></span><span style="display:flex;"><span>    $taskName = <span style="color:#e6db74">&#34;Schedule CHKDSK at 12AM&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">switch</span>($EVENTTYPE){
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;NTFS&#34;</span>{
</span></span><span style="display:flex;"><span>	    <span style="color:#75715e"># Check if CHKDSK task already exists</span>
</span></span><span style="display:flex;"><span>	    $taskExists = Get-ScheduledTask | Where-Object {$_.TaskName <span style="color:#f92672">-match</span> $taskName }
</span></span><span style="display:flex;"><span>	    <span style="color:#75715e"># Create task if it doesn&#39;t exist</span>
</span></span><span style="display:flex;"><span>	    <span style="color:#66d9ef">if</span> ($taskExists <span style="color:#f92672">-eq</span> $null){
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Find the volume letter from the event</span>
</span></span><span style="display:flex;"><span>		$eventString=($EVENT).message | Select-String -Pattern <span style="color:#e6db74">&#34;[A-Z]:&#34;</span> -AllMatches
</span></span><span style="display:flex;"><span>		$driveLetter=($eventString.Matches | Select -First <span style="color:#ae81ff">1</span>).value
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> ($driveLetter <span style="color:#f92672">-match</span> <span style="color:#e6db74">&#34;C:&#34;</span>){
</span></span><span style="display:flex;"><span>		    $action = New-ScheduledTaskAction -Execute <span style="color:#e6db74">&#34;C:\Windows\System32\cmd.exe /c &#39;echo y | chkdsk.exe /x /f </span>$driveLetter<span style="color:#e6db74"> &amp; shutdown /r /t 0 /f&#39;&#34;</span>
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>		    $action = New-ScheduledTaskAction -Execute <span style="color:#e6db74">&#34;C:\Windows\System32\cmd.exe /c &#39;echo y | chkdsk.exe /x /f </span>$driveLetter<span style="color:#e6db74">&#39;&#34;</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Schedule the task</span>
</span></span><span style="display:flex;"><span>		$trigger = New-ScheduledTaskTrigger -Once -At 12AM
</span></span><span style="display:flex;"><span>		$settings = New-ScheduledTaskSettingsSet -StartWhenAvailable:$true
</span></span><span style="display:flex;"><span>		$task = Register-ScheduledTask -TaskName $taskName -Trigger $trigger -Action $action -User System -Settings $settings
</span></span><span style="display:flex;"><span>		$task | Set-ScheduledTask
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Recreating the logfile show a scan was done</span>
</span></span><span style="display:flex;"><span>		Write-Host <span style="color:#e6db74">&#34;Corrupt Volume Chkdsk Scheduled: </span>$driveLetter<span style="color:#e6db74"> </span>$(Get-Date)<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>		Add-Content <span style="color:#e6db74">&#34;Corrupt Volume Chkdsk Scheduled: </span>$driveLetter<span style="color:#e6db74"> </span>$(Get-Date)<span style="color:#e6db74">&#34;</span> -Path $TXTLOG | Out-Null
</span></span><span style="display:flex;"><span>		_CreateEventLogEntry -LogName <span style="color:#e6db74">&#34;Application&#34;</span> -LogSource <span style="color:#e6db74">&#34;ChkdskScript&#34;</span> -Message <span style="color:#e6db74">&#34;Corrupt Volume Chkdsk Scheduled: </span>$driveLetter<span style="color:#e6db74"> </span>$(Get-Date)<span style="color:#e6db74">&#34;</span> -LogType <span style="color:#e6db74">&#34;Information&#34;</span>
</span></span><span style="display:flex;"><span>	    } <span style="color:#66d9ef">else</span>{<span style="color:#e6db74">&#34;CHKDSK Scheduled task already exists. Exiting&#34;</span> ; Exit <span style="color:#ae81ff">1</span>}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;Bad Block&#34;</span>{
</span></span><span style="display:flex;"><span>	    <span style="color:#75715e"># Check if CHKDSK task already exists</span>
</span></span><span style="display:flex;"><span>	    $taskExists = Get-ScheduledTask | Where-Object {$_.TaskName <span style="color:#f92672">-match</span> $taskName }
</span></span><span style="display:flex;"><span>	    <span style="color:#75715e"># Create task if it doesn&#39;t exist</span>
</span></span><span style="display:flex;"><span>	    <span style="color:#66d9ef">if</span> ($taskExists <span style="color:#f92672">-eq</span> $null){
</span></span><span style="display:flex;"><span>		$eventString = $EVENT.Message | Select-String -Pattern <span style="color:#e6db74">&#34;\\device\\Harddisk[1-100]\\...&#34;</span> -AllMatches
</span></span><span style="display:flex;"><span>		$driveName = ($eventString.Matches | Select -First <span style="color:#ae81ff">1</span>).value
</span></span><span style="display:flex;"><span>		$driveNumber = $driveName.Substring($driveName.length-<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>		$driveLetter = (_GetHarddiskVolumes | Where {$_.DevicePath <span style="color:#f92672">-like</span> <span style="color:#e6db74">&#34;*</span>$driveNumber<span style="color:#e6db74">&#34;</span>}).DriveLetter
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Reboot if the OS drive is scanned. Otherwise don&#39;t.</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> ($driveLetter <span style="color:#f92672">-match</span> <span style="color:#e6db74">&#34;C:&#34;</span>){
</span></span><span style="display:flex;"><span>		    $action = New-ScheduledTaskAction -Execute <span style="color:#e6db74">&#34;C:\Windows\System32\cmd.exe /c &#39;echo y | chkdsk.exe /x /f </span>$driveLetter<span style="color:#e6db74"> &amp; shutdown /r /t 0 /f&#39;&#34;</span>
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>		    $action = New-ScheduledTaskAction -Execute <span style="color:#e6db74">&#34;C:\Windows\System32\cmd.exe /c &#39;echo y | chkdsk.exe /x /f </span>$driveLetter<span style="color:#e6db74">&#39;&#34;</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		$trigger = New-ScheduledTaskTrigger -Once -At 11pm
</span></span><span style="display:flex;"><span>		$settings = New-ScheduledTaskSettingsSet -StartWhenAvailable:$true
</span></span><span style="display:flex;"><span>		$task = Register-ScheduledTask -TaskName $taskName -Trigger $trigger -Action $action -User System -Settings $settings
</span></span><span style="display:flex;"><span>		$task | Set-ScheduledTask
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Recreating the logfile show a scan was done</span>
</span></span><span style="display:flex;"><span>		Write-Host <span style="color:#e6db74">&#34;Corrupt Disk Chkdsk Scheduled: </span>$driveName<span style="color:#e6db74"> </span>$driveNumber<span style="color:#e6db74"> </span>$driveLetter<span style="color:#e6db74"> </span>$(Get-Date)<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>		Add-Content <span style="color:#e6db74">&#34;Corrupt Disk Chkdsk Scheduled: </span>$driveName<span style="color:#e6db74"> </span>$driveNumber<span style="color:#e6db74"> </span>$driveLetter<span style="color:#e6db74"> </span>$(Get-Date)<span style="color:#e6db74">&#34;</span> -Path $TXTLOG | Out-Null
</span></span><span style="display:flex;"><span>		_CreateEventLogEntry -LogName <span style="color:#e6db74">&#34;Application&#34;</span> -LogSource <span style="color:#e6db74">&#34;ChkdskScript&#34;</span> -Message <span style="color:#e6db74">&#34;Corrupt Disk Chkdsk Scheduled: </span>$driveName<span style="color:#e6db74"> </span>$driveNumber<span style="color:#e6db74"> </span>$driveLetter<span style="color:#e6db74"> </span>$(Get-Date)<span style="color:#e6db74">&#34;</span> -LogType <span style="color:#e6db74">&#34;Information&#34;</span>
</span></span><span style="display:flex;"><span>	    } <span style="color:#66d9ef">else</span>{<span style="color:#e6db74">&#34;CHKDSK Scheduled task already exists. Exiting&#34;</span> ; Exit <span style="color:#ae81ff">1</span>}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;Driver Detection&#34;</span>{
</span></span><span style="display:flex;"><span>	    <span style="color:#75715e"># Check if CHKDSK task already exists</span>
</span></span><span style="display:flex;"><span>	    $taskExists = Get-ScheduledTask | Where-Object {$_.TaskName <span style="color:#f92672">-match</span> $taskName }
</span></span><span style="display:flex;"><span>	    <span style="color:#75715e"># Create task if it doesn&#39;t exist</span>
</span></span><span style="display:flex;"><span>	    <span style="color:#66d9ef">if</span> ($taskExists <span style="color:#f92672">-eq</span> $null){
</span></span><span style="display:flex;"><span>		$eventString = $EVENT.Message | Select-String -Pattern <span style="color:#e6db74">&#34;\\device\\Harddisk[1-100]\\...&#34;</span> -AllMatches
</span></span><span style="display:flex;"><span>		$driveName = ($eventString.Matches | Select -First <span style="color:#ae81ff">1</span>).value
</span></span><span style="display:flex;"><span>		$driveNumber = $driveName.Substring($driveName.length-<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>		$driveLetter = (Get-CimInstance -ClassName Win32_DiskDrive |
</span></span><span style="display:flex;"><span>		  Where-Object {$_.DeviceID <span style="color:#f92672">-like</span> <span style="color:#e6db74">&#34;*</span>$driveNumber<span style="color:#e6db74">&#34;</span>} |
</span></span><span style="display:flex;"><span>		  Get-CimAssociatedInstance -Association Win32_DiskDriveToDiskPartition |
</span></span><span style="display:flex;"><span>		  Get-CimAssociatedInstance -Association Win32_LogicalDiskToPartition |
</span></span><span style="display:flex;"><span>		  Select-Object DeviceID).DeviceID
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> ($driveLetter <span style="color:#f92672">-match</span> <span style="color:#e6db74">&#34;C:&#34;</span>){
</span></span><span style="display:flex;"><span>		    $action = New-ScheduledTaskAction -Execute <span style="color:#e6db74">&#34;C:\Windows\System32\cmd.exe /c &#39;echo y | chkdsk.exe /x /f </span>$driveLetter<span style="color:#e6db74"> &amp; shutdown /r /t 0 /f&#39;&#34;</span>
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>		    $action = New-ScheduledTaskAction -Execute <span style="color:#e6db74">&#34;C:\Windows\System32\cmd.exe /c &#39;echo y | chkdsk.exe /x /f </span>$driveLetter<span style="color:#e6db74">&#39;&#34;</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		$trigger = New-ScheduledTaskTrigger -Once -At 11pm
</span></span><span style="display:flex;"><span>		$settings = New-ScheduledTaskSettingsSet -StartWhenAvailable:$true
</span></span><span style="display:flex;"><span>		$task = Register-ScheduledTask -TaskName $taskName -Trigger $trigger -Action $action -User System -Settings $settings
</span></span><span style="display:flex;"><span>		$task | Set-ScheduledTask
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Recreating the logfile show a scan was done</span>
</span></span><span style="display:flex;"><span>		Write-Host <span style="color:#e6db74">&#34;Corrupt Disk Chkdsk Scheduled: </span>$driveName<span style="color:#e6db74"> </span>$driveNumber<span style="color:#e6db74"> </span>$driveLetter<span style="color:#e6db74"> </span>$(Get-Date)<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>		Add-Content <span style="color:#e6db74">&#34;Corrupt Disk Chkdsk Scheduled: </span>$driveName<span style="color:#e6db74"> </span>$driveNumber<span style="color:#e6db74"> </span>$driveLetter<span style="color:#e6db74"> </span>$(Get-Date)<span style="color:#e6db74">&#34;</span> -Path $TXTLOG | Out-Null
</span></span><span style="display:flex;"><span>		_CreateEventLogEntry -LogName <span style="color:#e6db74">&#34;Application&#34;</span> -LogSource <span style="color:#e6db74">&#34;ChkdskScript&#34;</span> -Message <span style="color:#e6db74">&#34;Corrupt Disk Chkdsk Scheduled: </span>$driveName<span style="color:#e6db74"> </span>$driveNumber<span style="color:#e6db74"> </span>$driveLetter<span style="color:#e6db74"> </span>$(Get-Date)<span style="color:#e6db74">&#34;</span> -LogType <span style="color:#e6db74">&#34;Information&#34;</span>
</span></span><span style="display:flex;"><span>	    } <span style="color:#66d9ef">else</span>{<span style="color:#e6db74">&#34;CHKDSK Scheduled task already exists. Exiting&#34;</span> ; Exit <span style="color:#ae81ff">1</span>}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> _Main{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">param</span> (
</span></span><span style="display:flex;"><span>	[Parameter(<span style="color:#a6e22e">Mandatory</span>=$true)][<span style="color:#66d9ef">string</span>]$Email,
</span></span><span style="display:flex;"><span>	[Parameter(<span style="color:#a6e22e">Mandatory</span>=$true)][<span style="color:#66d9ef">string</span>]$Password,
</span></span><span style="display:flex;"><span>	[Parameter(<span style="color:#a6e22e">Mandatory</span>=$true)][<span style="color:#66d9ef">string</span>]$SMTPServer,
</span></span><span style="display:flex;"><span>	[Parameter(<span style="color:#a6e22e">Mandatory</span>=$true)][<span style="color:#66d9ef">string</span>]$SMTPPort,
</span></span><span style="display:flex;"><span>	[Parameter(<span style="color:#a6e22e">Mandatory</span>=$true)][<span style="color:#66d9ef">string</span>]$Recipient
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Scheduling the scans to run only if the last CHKDSK scan was done more than a week ago</span>
</span></span><span style="display:flex;"><span>    $TXTLOG = <span style="color:#e6db74">&#34;C:\Windows\LastChkdsk.txt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (Test-Path $TXTLOG){
</span></span><span style="display:flex;"><span>	$TXTLOGATTRIBUTES = Get-Item $TXTLOG -ErrorAction SilentlyContinue
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># If the log file is younger than 7 days...</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> ($TXTLOGATTRIBUTES.LastWriteTime <span style="color:#f92672">-gt</span> (Get-Date).AddDays(<span style="color:#ae81ff">-7</span>)){
</span></span><span style="display:flex;"><span>	    _CreateEventLogEntry -LogName <span style="color:#e6db74">&#34;Application&#34;</span> -LogSource <span style="color:#e6db74">&#34;ChkdskScript&#34;</span> -Message <span style="color:#e6db74">&#34;Corrupt Volume Chkdsk Scheduled: </span>$driveLetter<span style="color:#e6db74"> </span>$(Get-Date)<span style="color:#e6db74">&#34;</span> -LogType <span style="color:#e6db74">&#34;Information&#34;</span>
</span></span><span style="display:flex;"><span>	    <span style="color:#e6db74">&#34;Last scan was run on: &#34;</span> + $TXTLOGATTRIBUTES.LastWriteTime
</span></span><span style="display:flex;"><span>	    <span style="color:#e6db74">&#34;No action was taken since it was last done less than 7 days ago&#34;</span>
</span></span><span style="display:flex;"><span>	    <span style="color:#e6db74">&#34;This incident will be recorded since bad blocks are no bueno&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	    <span style="color:#75715e"># Sending the report email</span>
</span></span><span style="display:flex;"><span>	    &amp; .\sendmail.exe -I smtp.gmail.com -i $SMTPPort -u $Email -p $Password -r $Recipient -s <span style="color:#e6db74">&#34;Datto Possible Disk Failure&#34;</span> -m `
</span></span><span style="display:flex;"><span>	      <span style="color:#e6db74">&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">		The CHKDSK Monitor already repaired this drive.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">		An alert popped up again, which may indicate drive failure.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">		Check this computer out!
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">		Site Name: </span>$env:CS_PROFILE_NAME<span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">		Site UID: </span>$env:CS_PROFILE_UID<span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">		Device Name: </span>$env:COMPUTERNAME<span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">		Device Description: </span>$env:CS_PROFILE_DESC<span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">		Domain: </span>$env:CS_DOMAIN<span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">		&#34;</span>
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>	    <span style="color:#75715e"># Run the CHKDSK if $TXTLOG is older than 7 days</span>
</span></span><span style="display:flex;"><span>	    _ScheduleCHKDSK
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># Run the CHKDSK if $TXTLOG doesn&#39;t exist</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;Could not find </span>$TXTLOG<span style="color:#e6db74">. Running the script for the first time&#34;</span>
</span></span><span style="display:flex;"><span>	_ScheduleCHKDSK
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>_Main -Email EMAIL@EMAIL.COM -Password PASSWORDHERE -SMTPServer smtp.gmail.com -SMTPPort <span style="color:#ae81ff">587</span> -Recipient <span style="color:#e6db74">&#34;RECIPIENT@EMAIL.com&#34;</span></span></span></code></pre></div>
</div>
</div>
</div>

  </article>
</main>

</body>
</html>
